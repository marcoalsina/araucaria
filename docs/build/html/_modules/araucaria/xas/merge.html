

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>araucaria.xas.merge &mdash; araucaria 0.1.11
 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> araucaria
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../main_module.html">Main module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io_module.html">IO module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../xas_module.html">XAS module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../xrdb_module.html">XRDB module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../linalg_module.html">LinAlg module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fit_module.html">Fit module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plot_module.html">Plot module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stats_module.html">Statistics module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils_module.html">Utilities module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testdata_module.html">Testdata module</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">araucaria</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>araucaria.xas.merge</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for araucaria.xas.merge</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The :mod:`~araucaria.xas.merge` module offers the following functions to pre-process </span>
<span class="sd">and merge scans:</span>

<span class="sd">.. list-table::</span>
<span class="sd">   :widths: auto</span>
<span class="sd">   :header-rows: 1</span>

<span class="sd">   * - Function</span>
<span class="sd">     - Description</span>
<span class="sd">   * - :func:`calibrate`</span>
<span class="sd">     - Calibrates the absorption threshold energy of a scan.</span>
<span class="sd">   * - :func:`align`</span>
<span class="sd">     - Aligns a scan with respect to a reference.</span>
<span class="sd">   * - :func:`merge`</span>
<span class="sd">     - Merge groups in a collection.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">column_stack</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">gradient</span><span class="p">,</span> <span class="nb">sum</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Group</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Report</span>
<span class="kn">from</span> <span class="nn">.normalize</span> <span class="kn">import</span> <span class="n">find_e0</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">check_objattrs</span>

<div class="viewcode-block" id="calibrate"><a class="viewcode-back" href="../../../xas/xas_merge.html#araucaria.xas.merge.calibrate">[docs]</a><span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="n">group</span><span class="p">:</span> <span class="n">Group</span><span class="p">,</span> <span class="n">e0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calibrates the absorption threshold energy of the reference scan.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group</span>
<span class="sd">        Group containing the spectrum to calibrate.</span>
<span class="sd">    e0</span>
<span class="sd">        Arbitrary value for the absorption threshold.</span>
<span class="sd">    update</span>
<span class="sd">        Indicates if the group should be updated following calibration.</span>
<span class="sd">        The default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :</span>
<span class="sd">        Energy difference between ``e0`` and the initial energy threshold.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``group`` is not a valid Group instance.</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If attribute ``energy`` does not exist in ``group``.</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If attribute ``mu_ref`` does not exist in ``group``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Calibration is performed by offsetting the ``group.energy`` attribute in order</span>
<span class="sd">    to match the absorption threshold energy of ``group.mu_ref`` with the given ``e0`` </span>
<span class="sd">    value.</span>

<span class="sd">    If ``update=True`` the following attributes of ``group`` will be modified or created:</span>

<span class="sd">    - ``group.energy``: modified by the ``e_offset`` value.</span>
<span class="sd">    - ``group.e_offset``:  difference between ``e0`` and the initial| threshold energy.</span>

<span class="sd">    If ``update=False`` the ``e_offset`` value will be returned but not stored</span>
<span class="sd">    in ``group``.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    If ``e_offset`` already exists in the provided ``group``, the ``group.energy`` array will be </span>
<span class="sd">    reverted to its original values before performing calibration with the new ``e0`` value.</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    ~araucaria.xas.normalize.find_e0 : Finds the absorption threshold value.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.testdata import get_testpath</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.io import read_dnd</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.xas import calibrate</span>
<span class="sd">    &gt;&gt;&gt; fpath = get_testpath(&#39;dnd_testfile1.dat&#39;)</span>
<span class="sd">    &gt;&gt;&gt; group_mu = read_dnd(fpath, scan=&#39;mu&#39;)  # extracting mu and mu_ref scans</span>
<span class="sd">    &gt;&gt;&gt; e0       = 29200  # threshold energy for calibration</span>
<span class="sd">    &gt;&gt;&gt; e_offset = calibrate(group_mu, e0, update=False)  # energy offset</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;%1.3f&#39; % e_offset)</span>
<span class="sd">    -3.249</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># checking class and attributes</span>
    <span class="n">check_objattrs</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">Group</span><span class="p">,</span> <span class="n">attrlist</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">],</span> <span class="n">exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># auxiliary energy array</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">energy</span>
    
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s1">&#39;e_offset&#39;</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;group was already aligned or calibrated: resetting energy to original value.&#39;</span><span class="p">)</span>
        <span class="n">energy</span>   <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">energy</span> <span class="o">-</span> <span class="n">group</span><span class="o">.</span><span class="n">e_offset</span>

    <span class="c1"># auxiliary group</span>
    <span class="n">calgroup</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;energy&#39;</span><span class="p">:</span> <span class="n">energy</span><span class="p">,</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">mu_ref</span><span class="p">})</span>
    <span class="n">e_offset</span> <span class="o">=</span> <span class="n">e0</span><span class="o">-</span><span class="n">find_e0</span><span class="p">(</span><span class="n">calgroup</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
        <span class="c1"># updating the group</span>
        <span class="n">group</span><span class="o">.</span><span class="n">e_offset</span> <span class="o">=</span> <span class="n">e_offset</span>
        <span class="n">group</span><span class="o">.</span><span class="n">energy</span>   <span class="o">=</span> <span class="n">energy</span> <span class="o">+</span> <span class="n">e_offset</span>

    <span class="k">return</span> <span class="n">e_offset</span></div>

<div class="viewcode-block" id="align"><a class="viewcode-back" href="../../../xas/xas_merge.html#araucaria.xas.merge.align">[docs]</a><span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="n">group</span><span class="p">:</span> <span class="n">Group</span><span class="p">,</span> <span class="n">refgroup</span><span class="p">:</span> <span class="n">Group</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span> 
          <span class="n">use_mu_ref</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Aligns the scan of a data group with respect to a reference.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group</span>
<span class="sd">        Group containing the spectrum to align.</span>
<span class="sd">    refgroup</span>
<span class="sd">        Reference group for alignment.</span>
<span class="sd">    offset</span>
<span class="sd">        Initial energy offset for alignment. The default is 0.</span>
<span class="sd">    window</span>
<span class="sd">        Energy window with respect to `e0` to perform the alignent.</span>
<span class="sd">        The detaulf is [-50, 50].</span>
<span class="sd">    use_mu_ref</span>
<span class="sd">        Indicates if the reference scan of each group should be used </span>
<span class="sd">        for alignment. The default is True.</span>
<span class="sd">    update</span>
<span class="sd">        Indicates if the group should be updated following alignment.</span>
<span class="sd">        The default is True.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :</span>
<span class="sd">        Energy offset for the group after alignment.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If either ``group`` or ``refgroup`` is not a valid Group instance.</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If attribute ``energy`` does not exist in either ``group`` or ``refgroup``.</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If attribute ``mu_ref`` does not exist in either ``group`` or ``refgroup``</span>
<span class="sd">        when ``use_mu_ref = True``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The energy alignment is performed by minimizing the squared residuals between the</span>
<span class="sd">    derivative scans of ``group`` and ``refgroup``, considering an energy window computed</span>
<span class="sd">    with respect to the absorption threshold `e0` of ``refgroup``.</span>
<span class="sd">    </span>
<span class="sd">    If ``use_mu_ref=True`` the ``group.mu_ref`` array will be aligned with respect</span>
<span class="sd">    to the ``refgroup.mu_ref`` array. This is the default behavior.</span>
<span class="sd">    </span>
<span class="sd">    If ``use_mu_ref=False`` the scan attributes of ``group`` and ``refgroup`` will be </span>
<span class="sd">    used for alignment, as determined by the </span>
<span class="sd">    :func:`~araucaria.main.group.Group.get_mode` method.</span>

<span class="sd">    If ``update=True`` the following attributes of ``group`` will be modified or created:</span>
<span class="sd">    </span>
<span class="sd">    - ``group.energy``: modified by the ``e_offset`` value.</span>
<span class="sd">    - ``group.e_offset``:  energy offset following the alignment.</span>

<span class="sd">    If ``update=False`` the ``e_offset`` will be returned but not stored</span>
<span class="sd">    in ``group``.</span>

<span class="sd">    Important</span>
<span class="sd">    ---------</span>
<span class="sd">    The energy alignment performs a local optimization that depends on the </span>
<span class="sd">    initial ``offset`` parameter. Therefore a judicious selection of ``offset`` </span>
<span class="sd">    is required in order to obtain meaningful results.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    If ``e_offset`` already exists in the provided ``group``, the ``group.energy`` </span>
<span class="sd">    array will be reverted to its original values before performing alignment.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    ~araucaria.xas.normalize.find_e0 : Finds the absorption threshold value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import allclose</span>
<span class="sd">    &gt;&gt;&gt; from araucaria import Group</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.testdata import get_testpath</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.io import read_dnd</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.xas import align</span>
<span class="sd">    &gt;&gt;&gt; fpath = get_testpath(&#39;dnd_testfile1.dat&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # extracting mu and mu_ref scans</span>
<span class="sd">    &gt;&gt;&gt; group_mu = read_dnd(fpath, scan=&#39;mu&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # creating a reference group with an offset</span>
<span class="sd">    &gt;&gt;&gt; offset = 3.125</span>
<span class="sd">    &gt;&gt;&gt; ref = Group(**{&#39;energy&#39;: group_mu.energy + offset, </span>
<span class="sd">    ...                &#39;mu&#39;: group_mu.mu, </span>
<span class="sd">    ...                &#39;mu_ref&#39;: group_mu.mu_ref})</span>
<span class="sd">    &gt;&gt;&gt; # aligning with respect to &#39;mu_ref&#39;</span>
<span class="sd">    &gt;&gt;&gt; e_offset = align(group_mu, ref, update=False)</span>
<span class="sd">    &gt;&gt;&gt; allclose(offset, e_offset)</span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # aligning with respect to &#39;mu&#39;</span>
<span class="sd">    &gt;&gt;&gt; offset = 4.233</span>
<span class="sd">    &gt;&gt;&gt; ref = Group(**{&#39;energy&#39;: group_mu.energy + offset, </span>
<span class="sd">    ...                &#39;mu&#39;: group_mu.mu})</span>
<span class="sd">    &gt;&gt;&gt; e_offset = align(group_mu, ref, use_mu_ref=False, update=False)</span>
<span class="sd">    &gt;&gt;&gt; allclose(offset, e_offset)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="s1">&#39;refgroup&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">group</span><span class="p">,</span> <span class="n">refgroup</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid Group instance.&#39;</span> <span class="o">%</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">use_mu_ref</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has no &#39;mu_ref&#39; attribue.&quot;</span> <span class="o">%</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has no &#39;enery&#39; attribute.&quot;</span> <span class="o">%</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># auxiliary energy array</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">energy</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s1">&#39;e_offset&#39;</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;group already aligned or calibrated. Resetting energy to original value.&#39;</span><span class="p">)</span>
        <span class="n">energy</span>   <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">energy</span> <span class="o">-</span> <span class="n">group</span><span class="o">.</span><span class="n">e_offset</span>

    <span class="c1"># calculation of e0 to determine the optimization window</span>
    <span class="c1"># definition of reference spline</span>
    <span class="k">if</span> <span class="n">use_mu_ref</span><span class="p">:</span>
        <span class="n">e0</span>         <span class="o">=</span> <span class="n">find_e0</span><span class="p">(</span><span class="n">refgroup</span><span class="p">,</span> <span class="n">use_mu_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ref_spline</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">refgroup</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">refgroup</span><span class="o">.</span><span class="n">mu_ref</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scantype</span>   <span class="o">=</span> <span class="n">refgroup</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
        <span class="n">e0</span>         <span class="o">=</span> <span class="n">find_e0</span><span class="p">(</span><span class="n">refgroup</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ref_spline</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">refgroup</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">refgroup</span><span class="p">,</span> <span class="n">scantype</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>

    <span class="n">min_lim</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_lim</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># calculation of energy points for interpolation and comparison</span>
    <span class="c1"># this energy array is static</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">where</span><span class="p">((</span><span class="n">refgroup</span><span class="o">.</span><span class="n">energy</span> <span class="o">&gt;=</span> <span class="n">min_lim</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">refgroup</span><span class="o">.</span><span class="n">energy</span> <span class="o">&lt;=</span> <span class="n">max_lim</span><span class="p">))</span>
    <span class="n">ref_energy</span> <span class="o">=</span> <span class="n">refgroup</span><span class="o">.</span><span class="n">energy</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># both the reference mu and the objective mu</span>
    <span class="c1"># exist in the same energy grid as the reference</span>
    <span class="n">ref_dmu</span> <span class="o">=</span> <span class="n">gradient</span><span class="p">(</span><span class="n">ref_spline</span><span class="p">(</span><span class="n">ref_energy</span><span class="p">))</span><span class="o">/</span><span class="n">gradient</span><span class="p">(</span><span class="n">ref_energy</span><span class="p">)</span>

    <span class="c1"># the objective function is the difference of derivatives</span>
    <span class="k">if</span> <span class="n">use_mu_ref</span><span class="p">:</span>
        <span class="n">scantype</span> <span class="o">=</span> <span class="s1">&#39;mu_ref&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scantype</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">objfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">obj_spline</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">energy</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">scantype</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="n">obj_dmu</span> <span class="o">=</span> <span class="n">gradient</span><span class="p">(</span><span class="n">obj_spline</span><span class="p">(</span><span class="n">ref_energy</span><span class="p">))</span><span class="o">/</span><span class="n">gradient</span><span class="p">(</span><span class="n">ref_energy</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">ref_dmu</span> <span class="o">-</span> <span class="n">obj_dmu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">e_offset</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="n">objfunc</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
        <span class="n">group</span><span class="o">.</span><span class="n">e_offset</span> <span class="o">=</span> <span class="n">e_offset</span>
        <span class="n">group</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span> <span class="o">+</span> <span class="n">e_offset</span>

    <span class="k">return</span> <span class="n">e_offset</span></div>

<div class="viewcode-block" id="merge"><a class="viewcode-back" href="../../../xas/xas_merge.html#araucaria.xas.merge.merge">[docs]</a><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">collection</span><span class="p">:</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">taglist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">],</span> 
          <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;merge&#39;</span><span class="p">,</span> <span class="n">only_mu_ref</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Report</span><span class="p">,</span> <span class="n">Group</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Merge groups in a collection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    collection</span>
<span class="sd">        Collection with the groups to be merged.</span>
<span class="sd">    taglist</span>
<span class="sd">        List with keys to filter groups to be merged based </span>
<span class="sd">        on their ``tags`` attributes in the Collection.</span>
<span class="sd">        The default is [&#39;all&#39;].</span>
<span class="sd">    name</span>
<span class="sd">        Name for the merged group.</span>
<span class="sd">        The default is &#39;merge&#39;.</span>
<span class="sd">    only_mu_ref</span>
<span class="sd">        Indicates if only the reference scans should be merged.</span>
<span class="sd">        The default is False.</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    report</span>
<span class="sd">        Report for the merged scan.</span>
<span class="sd">    group</span>
<span class="sd">        Group containing the merged scan.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``collection`` is not a valid Collection instance.</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If ``collection`` has no ``tags`` attribute.</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If attribute ``mu_ref`` does not exist in the selected groups.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any item in ``taglist`` is not a key of the ``tags`` attribute.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    If only one group in ``collection`` is selected for merge, a None report </span>
<span class="sd">    and the single group will be returned.</span>
<span class="sd">    </span>
<span class="sd">    If different scan types are being merged, the scan attribute of the merge </span>
<span class="sd">    group will be labeled ``mu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If ``only_mu_ref=False`` the scan arrays of the selected groups will be </span>
<span class="sd">    merged, as determined by the :func:`~araucaria.main.group.Group.get_mode` </span>
<span class="sd">    method. The ``mu_ref`` arrays of the selected groups will also be merged </span>
<span class="sd">    separately. This is the detault behavior.</span>
<span class="sd">    </span>
<span class="sd">    If ``only_mu_ref=True`` only the ``mu_ref`` arrays of the selected groups </span>
<span class="sd">    will be merged.</span>
<span class="sd">    </span>
<span class="sd">    The following attribute will be created for the returned group:</span>
<span class="sd">    </span>
<span class="sd">    - ``group.merged_scans``: list with the merged scan files.</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`~araucaria.plot.fig_merge.fig_merge`: Plots merged scans.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from araucaria import Collection</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.testdata import get_testpath</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.io import read_dnd</span>
<span class="sd">    &gt;&gt;&gt; from araucaria.xas import merge</span>
<span class="sd">    &gt;&gt;&gt; collection = Collection()</span>
<span class="sd">    &gt;&gt;&gt; files = [&#39;dnd_testfile1.dat&#39; , &#39;dnd_testfile2.dat&#39;, &#39;dnd_testfile3.dat&#39;]</span>
<span class="sd">    &gt;&gt;&gt; for file in files:</span>
<span class="sd">    ...     fpath = get_testpath(file)</span>
<span class="sd">    ...     group_mu = read_dnd(fpath, scan=&#39;mu&#39;)  # extracting mu and mu_ref scans</span>
<span class="sd">    ...     collection.add_group(group_mu)         # adding group to collection</span>
<span class="sd">    &gt;&gt;&gt; report, mgroup = merge(collection)</span>
<span class="sd">    &gt;&gt;&gt; report.show()</span>
<span class="sd">    ===================================================</span>
<span class="sd">    id  filename           mode  e_offset[eV]  e0[eV]  </span>
<span class="sd">    ===================================================</span>
<span class="sd">    1   dnd_testfile1.dat  mu    0             29203   </span>
<span class="sd">    2   dnd_testfile2.dat  mu    0             29203   </span>
<span class="sd">    3   dnd_testfile3.dat  mu    0             29203   </span>
<span class="sd">    ---------------------------------------------------</span>
<span class="sd">        merge              mu    0             29203   </span>
<span class="sd">    ===================================================</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># checking class and attributes</span>
    <span class="n">check_objattrs</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">attrlist</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;tags&#39;</span><span class="p">],</span> <span class="n">exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">listgroups</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">get_names</span><span class="p">(</span><span class="n">taglist</span><span class="o">=</span><span class="n">taglist</span><span class="p">)</span>

    <span class="c1"># initializing report</span>
    <span class="n">names</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;e_offset[eV]&#39;</span><span class="p">,</span> <span class="s1">&#39;e0[eV]&#39;</span><span class="p">]</span>
    <span class="n">report</span> <span class="o">=</span> <span class="n">Report</span><span class="p">()</span>
    <span class="n">report</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">listgroups</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has no &#39;mu_ref&#39; attribute.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">listgroups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;single group selected for merge. Returning that group.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">collection</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">listgroups</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">energy</span>   <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">get_mcer</span><span class="p">(</span><span class="n">taglist</span><span class="o">=</span><span class="n">taglist</span><span class="p">)</span>
    <span class="n">scanlist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># container for scan types</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listgroups</span><span class="p">):</span>
        <span class="n">group</span>    <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># storing energy offset</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">e_offset</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">e_offset</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">e_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># interpolating and storing the reference channel</span>
        <span class="n">mu_ref_spline</span><span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">mu_ref</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mu_ref</span> <span class="o">=</span> <span class="n">mu_ref_spline</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu_ref</span> <span class="o">=</span> <span class="n">column_stack</span><span class="p">((</span><span class="n">mu_ref</span><span class="p">,</span> <span class="n">mu_ref_spline</span><span class="p">(</span><span class="n">energy</span><span class="p">)))</span>

        <span class="c1"># interpolating and storing the scan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_mu_ref</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
            <span class="n">scanlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
            <span class="n">mu_spline</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">mode</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
            <span class="k">if</span>  <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_spline</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="n">column_stack</span><span class="p">((</span><span class="n">mu</span><span class="p">,</span> <span class="n">mu_spline</span><span class="p">(</span><span class="n">energy</span><span class="p">)))</span>

            <span class="c1"># storing data on report</span>
            <span class="n">e0</span> <span class="o">=</span> <span class="n">find_e0</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">e_offset</span><span class="p">,</span> <span class="n">e0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e0</span> <span class="o">=</span> <span class="n">find_e0</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">use_mu_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">,</span> <span class="n">e_offset</span><span class="p">,</span> <span class="n">e0</span><span class="p">])</span>
        
    <span class="n">mu_ref_avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">mu_ref</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    
    
    <span class="c1"># adding midrule</span>
    <span class="n">report</span><span class="o">.</span><span class="n">add_midrule</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">only_mu_ref</span><span class="p">:</span>
        <span class="c1"># calculating the average of the spectra</span>
        <span class="n">mu_avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">item</span> <span class="o">==</span> <span class="n">mode</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">scanlist</span><span class="p">):</span>
            <span class="n">merge</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span><span class="n">energy</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span><span class="n">mu_avg</span><span class="p">,</span>
                             <span class="s1">&#39;mu_ref&#39;</span><span class="p">:</span><span class="n">mu_ref_avg</span><span class="p">})</span>
            <span class="n">mergescan</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merge</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span><span class="n">energy</span><span class="p">,</span> <span class="s1">&#39;mu&#39;</span><span class="p">:</span><span class="n">mu_avg</span><span class="p">,</span> 
                             <span class="s1">&#39;mu_ref&#39;</span><span class="p">:</span><span class="n">mu_ref_avg</span><span class="p">})</span>
            <span class="n">mergescan</span> <span class="o">=</span> <span class="s1">&#39;mu&#39;</span>
        
        <span class="c1"># storing data on report</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="n">find_e0</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">name</span><span class="p">,</span> <span class="n">mergescan</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">e0</span><span class="p">])</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">merge</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span><span class="n">energy</span><span class="p">,</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">:</span><span class="n">mu_ref_avg</span><span class="p">})</span>
        
        <span class="c1"># storing data on report</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="n">find_e0</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="n">use_mu_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;mu_ref&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">e0</span><span class="p">])</span>

    <span class="nb">setattr</span><span class="p">(</span><span class="n">merge</span><span class="p">,</span> <span class="s1">&#39;merged_scans&#39;</span><span class="p">,</span> <span class="n">listgroups</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="n">merge</span><span class="p">)</span></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020-2021, Marco A. Alsina.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>